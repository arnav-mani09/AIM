import math
import subprocess
from pathlib import Path
from typing import List

from sqlalchemy.orm import Session

from app.models.film_segment import FilmSegment
from app.models.game_upload import GameUpload


class FilmProcessingService:
    """Extracts basic metadata from uploads and creates placeholder segments."""

    def __init__(self, db: Session):
        self.db = db

    def process_upload(self, upload_id: int) -> None:
        upload = (
            self.db.query(GameUpload)
            .filter(GameUpload.id == upload_id)
            .first()
        )
        if not upload or not upload.storage_url:
            return

        duration = self._probe_duration(Path(upload.storage_url))
        if duration is not None:
            upload.duration_seconds = int(duration)

        # Only add suggestions if none exist yet so we do not duplicate work.
        existing_segments = (
            self.db.query(FilmSegment)
            .filter(FilmSegment.upload_id == upload.id)
            .count()
        )
        if existing_segments == 0 and duration and duration > 0:
            segments = self._suggest_segments(duration)
            for segment in segments:
                film_segment = FilmSegment(
                    upload_id=upload.id,
                    start_second=segment["start"],
                    end_second=segment["end"],
                    label=segment["label"],
                    notes=segment["notes"],
                )
                self.db.add(film_segment)

        self.db.commit()

    def _probe_duration(self, path: Path) -> float | None:
        """Use ffprobe if available to detect duration of the uploaded video."""
        if not path.exists():
            return None
        try:
            result = subprocess.run(
                [
                    "ffprobe",
                    "-v",
                    "error",
                    "-select_streams",
                    "v:0",
                    "-show_entries",
                    "format=duration",
                    "-of",
                    "default=noprint_wrappers=1:nokey=1",
                    str(path),
                ],
                capture_output=True,
                text=True,
                check=True,
            )
            return float(result.stdout.strip())
        except FileNotFoundError:
            return path.stat().st_size / 4_000_000 if path.stat().st_size else None
        except (subprocess.SubprocessError, ValueError):
            return None

    def _suggest_segments(self, duration: float) -> List[dict]:
        """Create evenly spaced placeholder segments."""
        if duration <= 0:
            return []
        if duration < 8:
            total_segments = 1
        elif duration < 24:
            total_segments = 2
        elif duration < 60:
            total_segments = 3
        else:
            total_segments = min(6, math.ceil(duration / 25))
        segment_length = duration / total_segments
        segment_length = max(5, min(segment_length, 25))

        suggestions = []
        current = 0.0
        index = 1
        while current < duration and index <= total_segments:
            end = min(duration, current + segment_length)
            if end - current < 2:
                break
            suggestions.append(
                {
                    "start": int(current),
                    "end": int(end),
                    "label": f"Suggested segment {index}",
                    "notes": "Auto-generated by AIM.",
                }
            )
            current = end
            index += 1
        return suggestions
